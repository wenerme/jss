package jss.proto.packet.connection;

import com.github.mpjct.jmpjct.mysql.proto.define.Flags;
import io.netty.buffer.ByteBuf;
import java.util.Map;
import jss.proto.define.CapabilityFlag;
import jss.proto.packet.Packet;
import jss.proto.util.Dumper;

/**
 * Handshake Response Packet sent by 4.1+ clients supporting CLIENT_PROTOCOL_41 capability, if the server announced it in its Initial Handshake Packet. Otherwise (talking to an old server) the Protocol::HandshakeResponse320 packet has to be used.
 * <pre>
 *
 *
 * Payload
 * 4              capability flags, CLIENT_PROTOCOL_41 always set
 * 4              max-packet size
 * 1              character set
 * string[23]     reserved (all [0])
 * string[NUL]    username
 * if capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA {
 * lenenc-int     length of auth-response
 * string[n]      auth-response
 * } else if capabilities & CLIENT_SECURE_CONNECTION {
 * 1              length of auth-response
 * string[n]      auth-response
 * } else {
 * string[NUL]    auth-response
 * }
 * if capabilities & CLIENT_CONNECT_WITH_DB {
 * string[NUL]    database
 * }
 * if capabilities & CLIENT_PLUGIN_AUTH {
 * string[NUL]    auth plugin name
 * }
 * if capabilities & CLIENT_CONNECT_ATTRS {
 * lenenc-int     length of all key-values
 * lenenc-str     key
 * lenenc-str     value
 * if-more data in 'length of all key-values', more keys and value pairs
 * }
 *
 * Fields
 * capability_flags (4) -- capability flags of the client as defined in Protocol::CapabilityFlags
 *
 * max_packet_size (4) -- max size of a command packet that the client wants to send to the server
 *
 * character_set (1) -- connection's default character set as defined in Protocol::CharacterSet.
 *
 * username (string.fix_len) -- name of the SQL account which client wants to log in -- this string should be interpreted using the character set indicated by character set field.
 *
 * auth-response (string.NUL) -- opaque authentication response data generated by Authentication Method indicated by the plugin name field.
 *
 * database (string.NUL) -- initail database for the connection -- this string should be interpreted using the character set indicated by character set field.
 *
 * auth plugin name (string.NUL) -- the Authentication Method used by the client to generate auth-response value in this packet. This is an UTF-8 string.
 *
 * Example
 * On MySQL 5.5.8 with CLIENT_PROTOCOL_41 CLIENT_PLUGIN_AUTH, CLIENT_SECURE_CONNECTION, and CLIENT_CONNECT_WITH_DB set, it may look like:
 *
 * 54 00 00 01 8d a6 0f 00    00 00 00 01 08 00 00 00    T...............
 * 00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00    ................
 * 00 00 00 00 70 61 6d 00    14 ab 09 ee f6 bc b1 32    ....pam........2
 * 3e 61 14 38 65 c0 99 1d    95 7d 75 d4 47 74 65 73    >a.8e....}u.Gtes
 * 74 00 6d 79 73 71 6c 5f    6e 61 74 69 76 65 5f 70    t.mysql_native_p
 * 61 73 73 77 6f 72 64 00                               assword.
 * Starting with MySQL 5.6.6 the client may send attributes if CLIENT_CONNECT_ATTRS is set:
 *
 * b2 00 00 01 85 a2 1e 00    00 00 00 40 08 00 00 00    ...........@....
 * 00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00    ................
 * 00 00 00 00 72 6f 6f 74    00 14 22 50 79 a2 12 d4    ....root.."Py...
 * e8 82 e5 b3 f4 1a 97 75    6b c8 be db 9f 80 6d 79    .......uk.....my
 * 73 71 6c 5f 6e 61 74 69    76 65 5f 70 61 73 73 77    sql_native_passw
 * 6f 72 64 00 61 03 5f 6f    73 09 64 65 62 69 61 6e    ord.a._os.debian
 * 36 2e 30 0c 5f 63 6c 69    65 6e 74 5f 6e 61 6d 65    6.0._client_name
 * 08 6c 69 62 6d 79 73 71    6c 04 5f 70 69 64 05 32    .libmysql._pid.2
 * 32 33 34 34 0f 5f 63 6c    69 65 6e 74 5f 76 65 72    2344._client_ver
 * 73 69 6f 6e 08 35 2e 36    2e 36 2d 6d 39 09 5f 70    sion.5.6.6-m9._p
 * 6c 61 74 66 6f 72 6d 06    78 38 36 5f 36 34 03 66    latform.x86_64.f
 * 6f 6f 03 62 61 72                                     oo.bar
 * Caution
 * Currently, multibyte character sets such as UCS2, UTF16 and UTF32 are not supported.
 *
 * Note
 * If client wants to have a secure SSL connection and sets CLIENT_SSL flag it should first send the SSL Request Packet and only then, after establishing the secure connection, it should send the Handshake Response Packet.
 * </pre>
 *
 * @see <a href=http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse41>HandshakeResponse41</a>
 */
public class HandshakeResponse41 implements Packet
{
    public int capabilityFlags = Flags.CLIENT_PROTOCOL_41;
    public int maxPacketSize = 0;
    public int characterSet = 0;
    public ByteBuf reserved;
    public ByteBuf username;
    public long authResponseLen = 0;
    public ByteBuf authResponse;
    public ByteBuf database;
    public ByteBuf authPluginName;
    public long keyValuesLength = 0;
//    public ByteBuf key;
//    public ByteBuf value;

    public Map<String, String> attributes;

    @Override
    public String toString()
    {
        return "HandshakeResponse41{" +
                "capabilityFlags=" + Dumper.dump(capabilityFlags, CapabilityFlag.class) +
                ", maxPacketSize=" + maxPacketSize +
                ", characterSet=" + characterSet +
                ", reserved=" + Dumper.dump(reserved) +
                ", username=" + Dumper.string(username) +
                ", authResponseLen=" + authResponseLen +
                ", authResponse=" + Dumper.dump(authResponse) +
                ", database=" + Dumper.string(database) +
                ", authPluginName=" + Dumper.string(authPluginName) +
                ", keyValuesLength=" + keyValuesLength +
                ", attributes=" + attributes +
                '}';
    }
}
